<html>

<head>
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <meta charset="utf-8">
    <title>PULSO WebHid Demo</title>
    <style>
        body {
            margin: 0;
        }

        #gui_containerR{
  position: absolute;
  top: 1%;
  left: 80%;
}
                #gui_containerL{
  position: absolute;
  top: 1%;
  left: 2%;
}
#guiR{
  #transform:translate(-50%, -75px);
}
#guiL{
  #transform:translate(50%, -75px);
}

#graphContainer
{
    position:absolute;
    left:50%;
}

canvas {
    border: 1.5px solid black;
    width: 300px;
    height: 300px;
}
    </style>

<!--
 <script src="ML/structs.js"></script>
    <script src="ML/tools.js"></script>
    <script src="ML/flow.js"></script>
    <script src="ML/weights.js"></script>
    <script src="ML/input_examples.js"></script>
    <script src="ML/test.js"></script>
-->
</head>

<body>

   

    <div id="gui_containerR"></div>
    <div id="gui_containerL"></div>

    <!--div id="debug"></div-->


    <script src="./build/three.js"></script>


    <script type="module">

        import { FBXLoader } from './FBXLoader.js';
        import { OrbitControls } from './jsm/controls/OrbitControls.js';
        import { GUI } from './jsm/libs/dat.gui.module.js';

        var canvas = document.getElementById('myCanvas'),
            ctx = canvas.getContext('2d'),
            width = canvas.width,
            height = canvas.height;
    // capture incoming socket data in an array
        var data = [];
        var data2 = [];
        var data3 = [];
        var data4 = [];
        var data5 = [];
		

		
		document.addEventListener("keydown", onDocumentKeyDown, false);
function onDocumentKeyDown(event) {
    var keyCode = event.which;
    if (keyCode == 87) {
      //  alert('jk')
    } else if (keyCode == 83) {
     //  alert('jk')
    } else if (keyCode == 65) {
      // alert('jk')
    } else if (keyCode == 68) {
      // alert('jk')
    } else if (keyCode == 32) {
      SetGyroZero(true);
    }
};



    // TESTING: fill data with some test values
        /*
    for (var i = 0; i < 50; i++) {
        data.push(Math.sin(i / 10) * 70 + 100);
    }
    */

    var x = 0;
var panAtX = 150;
var continueAnimation = true;
//animateGraph();


function animateGraph() {

    if (x > data.length - 1) {
        return;
    }

    /*
    if (continueAnimation) {
        requestAnimationFrame(animateGraph);
    }
    */

    if (x++ < panAtX) {

        ctx.fillStyle = "red";
        ctx.fillRect(x, data[x], 1, 1);
        ctx.fillStyle = "orange";
        ctx.fillRect(x, data2[x], 1, 1);
        ctx.fillStyle = "yellow";
        ctx.fillRect(x, data3[x], 1, 1);
        ctx.fillStyle = "green";
        ctx.fillRect(x, data4[x], 1, 1);
        ctx.fillStyle = "blue";
        ctx.fillRect(x, data5[x], 1, 1);

    } else {

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // plot data[] from x-PanAtX to x 

        for (var xx = 0; xx < panAtX; xx++) {
            var y = data[x - panAtX + xx];
            ctx.fillStyle = "red";
            ctx.fillRect(xx, y, 1, 1);
            y = data2[x - panAtX + xx];
            ctx.fillStyle = "orange";
            ctx.fillRect(xx, y, 1, 1);
            y = data3[x - panAtX + xx];
            ctx.fillStyle = "yellow";
            ctx.fillRect(xx, y, 1, 1);
                        y = data4[x - panAtX + xx];
            ctx.fillStyle = "green";
            ctx.fillRect(xx, y, 1, 1);
                        y = data5[x - panAtX + xx];
            ctx.fillStyle = "blue";
            ctx.fillRect(xx, y, 1, 1);
        }
    }
}


        class AIProcessor {
            constructor(bufferLen) {
                this._bufferLen = bufferLen;
                this._buffer = [];
            }

            UpdateBuffer(newVal)
            {
                this._buffer.push(newVal);

                if (this._buffer.length > this._bufferLen) {
                    var i = this._buffer.shift();
                }
            }

            DetectPeaks(data, windowWidth, threshold) {
              const peaks = [];
              for (let i = 0; i < data.length; i++) {
                const start = Math.max(0, i - windowWidth);
                const end = Math.min(data.length, i + windowWidth);
                let deltaAcc = 0;
                for (let a = start; a < end; a++) {
                  deltaAcc += Math.abs(data[a - 1] - data[a]);
                }
                if (deltaAcc > threshold) {
                  peaks.push(i);
                }
              }
              return peaks;
            }
        }

        class PulsoHand {
            constructor(hand, isRightSide) {
                this._lastGyro = new THREE.Quaternion(1, 1, 1, 1);
                this._hand = hand;
                this._fingers = [];
                this._fingersArray_0_to_255 = [0,0,0,0,0];
                this._gui;
                this._guiFingerSliders;
                this._GUI_gloveFolder;

                this._inited = false;
                this._rightHand = isRightSide;
                this._battery = 0;

                //this._callibrationMode = false;
                this._callibrationFingersPose = [0.5, 0.5, 0.5, 0.5, 0.5];

                this._axisType = 7;
                this._originRotationLocal = new THREE.Quaternion(0, 0, 0, 1);
                this._offset = new THREE.Quaternion(1, 1, 1, 1);

                this._params = {
            HID_Data: "wait connecting...",
            Connect : function() 
            {
                ConnectPulsoBluetooth(isRightSide);
            },
            SetMinuses: SetMinuses,
            SetHandRot: SetHandRot,
            StartSend: function() 
            {
                StartSend(isRightSide);
            },
            StopSend: function() 
            {
                StopSend(isRightSide);
            },
            SwitchNormal: function() 
            {
                SwitchNormal(isRightSide);
            },
            SwitchGyro: function() 
            {
                SwitchGyro(isRightSide);
            },
			SwitchRaw: function() 
            {
                SwitchRaw(isRightSide);
            },
            Vibro: function() 
            {
                Vibro(isRightSide);
            },
            Callibrate: function() 
            {
                Callibrate(isRightSide);
            },
            Reset: function() 
            {
                Reset(isRightSide);
            },
            SetGyroZero: function() 
            {
                SetGyroZero(isRightSide);
            },
	    CallibrateGyro:function()
{
CallibrateGyro(isRightSide);
},
            CallibrateFingersPose: function ()
            {
                CallibratePulsoFingers(isRightSide);
                    },
          
            handXPos: 0,
            //DrawBoxes: true,
                    SceneColor: '#3e3e3e',
            Battery : 0,
                    finger0: 0, finger1: 0, finger2: 0, finger3: 0, finger4: 0,
                    handZPos: 0, rotX: 0, rotY: 0, rotZ: 0, accX: 0, accY: 0, accZ: 0
        };
            }

            InitFingers() {
                this._fingers[0] = new Finger();
                this._fingers[1] = new Finger();
                this._fingers[2] = new Finger();
                this._fingers[3] = new Finger();
                this._fingers[4] = new Finger();

                this._fingers[0].InitBones(this._hand, ["finger_thumb_1_r", "finger_thumb_2_r"]);
                this._fingers[1].InitBones(this._hand, ["finger_index_0_r", "finger_index_1_r", "finger_index_2_r"]);
                this._fingers[2].InitBones(this._hand, ["finger_middle_0_r", "finger_middle_1_r", "finger_middle_2_r"]);
                this._fingers[3].InitBones(this._hand, ["finger_ring_0_r", "finger_ring_1_r", "finger_ring_2_r"]);
                this._fingers[4].InitBones(this._hand, ["finger_pinky_0_r", "finger_pinky_1_r", "finger_pinky_2_r"]);
            }

            CallibrateFingers() {
                for (var i = 0; i < 5; i++)
                {
                    this._fingers[i]._multiplyKoef = GetBaseLog(this._fingers[i]._normalizedRawValue, this._callibrationFingersPose[i]);
                    //console.log("GetBaseLog " + this._callibrationFingersPose[i] + " : " + this._fingers[i]._normalizedRawValue + " = " + this._fingers[i]._multiplyKoef);
                }
            }

            ResetCallibration() {
                for (var i = 0; i < 5; i++) {
                    this._fingers[i]._multiplyKoef = 1.0;
                }
            }

            ParseData(reportID, gloveData)
            {
		//console.log(gloveData);
		
				//console.log(gloveData.byteLength)
				
				

				
				let ax = 0;//map(res[9], 0, 255, -1.0, 1.0);
				let ay = 0;//map(res[10], 0, 255, -1.0, 1.0);
				let az = 0;//map(res[11], 0, 255, -1.0, 1.0);

				
				if (reportID == 1)
				{
					let res = [];
					
						for (var i = 0; i < gloveData.byteLength; i++) {
							res[i] = gloveData.getUint8(i);
						}
					
					//console.log(res);
			
					this._gui.__controllers[0].setValue(res);
				
					for (var i = 0; i < 5; i++) {
						this._fingersArray_0_to_255[i] = parseInt(res[i]);
					}
					
					for (var i = 0; i < 5; i++) {
						this._fingers[i].Update(this._fingersArray_0_to_255[i]);
					}
					
					this._battery = lerp(this._battery, res[13], 0.01);
					
					ax = res[9];//map(res[9], 0, 255, -1.0, 1.0);
					ay = res[10];//map(res[10], 0, 255, -1.0, 1.0);
					az = res[11];//map(res[11], 0, 255, -1.0, 1.0);

					
				let mldata = [];

				for (var i = 0; i < 5; i++) {
						mldata[i] = this._fingers[i]._multiplyValue;
					}
				}
				
				if (reportID == 3)
				{
					/*
					let res = [];
				
					for (var i = 0; i < 5; i++) {
						res[i] = gloveData.getUint16(i);
					}
					
					console.log(res);
					*/
					
					let res8 = [];
				
					for (var i = 0; i < gloveData.byteLength; i++) {
						res8[i] = gloveData.getUint8(i);
					}
				
					//console.log(res8);
					
					let res = [];
					
					for (var i = 0; i < 8; i+=2) {
						var bytes = new Uint8Array(2);
						bytes[1] = res8[i];
						bytes[0] = res8[i+1];
						var result = ( ( (bytes[0] & 0xFF) << 8) | (bytes[1] & 0xFF) );
						res[i/2] = result;
					}
					
					//console.log(res);
					
					let x = map(res[0], 0, 65535, -1.0, 1.0);
					let y = map(res[1], 0, 65535, -1.0, 1.0);
					let z = map(res[2], 0, 65535, -1.0, 1.0);
					let w = map(res[3], 0, 65535, -1.0, 1.0);
					
					
					this._lastGyro.set(x, y, z, w);
				}

		////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////flow.add(mldata);

/*
            for (var i = 0; i < this._guiFingerSliders.__controllers.length; i++) {
                if (this._guiFingerSliders.__controllers[i].property == "finger0")
                    this._guiFingerSliders.__controllers[i].setValue(this._fingersArray_0_to_255[0]);
                if (this._guiFingerSliders.__controllers[i].property == "finger1")
                    this._guiFingerSliders.__controllers[i].setValue(this._fingersArray_0_to_255[1]);
                if (this._guiFingerSliders.__controllers[i].property == "finger2")
                    this._guiFingerSliders.__controllers[i].setValue(this._fingersArray_0_to_255[2]);
                if (this._guiFingerSliders.__controllers[i].property == "finger3")
                    this._guiFingerSliders.__controllers[i].setValue(this._fingersArray_0_to_255[3]);
                if (this._guiFingerSliders.__controllers[i].property == "finger4")
                    this._guiFingerSliders.__controllers[i].setValue(this._fingersArray_0_to_255[4]);
                if (this._guiFingerSliders.__controllers[i].property == "rotX")
                    this._guiFingerSliders.__controllers[i].setValue(radians_to_degrees(this._hand.parent.rotation.x));
                if (this._guiFingerSliders.__controllers[i].property == "rotY")
                    this._guiFingerSliders.__controllers[i].setValue(radians_to_degrees(this._hand.parent.rotation.y));
                if (this._guiFingerSliders.__controllers[i].property == "rotZ")
                    this._guiFingerSliders.__controllers[i].setValue(radians_to_degrees(this._hand.parent.rotation.z));
            }
            */

			if (reportID == 1){
					for (var i = 0; i < this._guiFingerSliders.__controllers.length; i++) {
						if (this._guiFingerSliders.__controllers[i].property == "finger0")
							this._guiFingerSliders.__controllers[i].setValue(this._fingers[0]._multiplyValue);
					if (this._guiFingerSliders.__controllers[i].property == "finger1")
						this._guiFingerSliders.__controllers[i].setValue(this._fingers[1]._multiplyValue);
					if (this._guiFingerSliders.__controllers[i].property == "finger2")
						this._guiFingerSliders.__controllers[i].setValue(this._fingers[2]._multiplyValue);
					if (this._guiFingerSliders.__controllers[i].property == "finger3")
						this._guiFingerSliders.__controllers[i].setValue(this._fingers[3]._multiplyValue);
					if (this._guiFingerSliders.__controllers[i].property == "finger4")
						this._guiFingerSliders.__controllers[i].setValue(this._fingers[4]._multiplyValue);
						if (this._guiFingerSliders.__controllers[i].property == "rotX")
							this._guiFingerSliders.__controllers[i].setValue(radians_to_degrees(this._hand.parent.rotation.x));
					if (this._guiFingerSliders.__controllers[i].property == "rotY")
						this._guiFingerSliders.__controllers[i].setValue(radians_to_degrees(this._hand.parent.rotation.y));
					if (this._guiFingerSliders.__controllers[i].property == "rotZ")
						this._guiFingerSliders.__controllers[i].setValue(radians_to_degrees(this._hand.parent.rotation.z));
					  

			if (this._guiFingerSliders.__controllers[i].property == "accX")
							this._guiFingerSliders.__controllers[i].setValue(ax);
					if (this._guiFingerSliders.__controllers[i].property == "accY")
							this._guiFingerSliders.__controllers[i].setValue(ay);
					if (this._guiFingerSliders.__controllers[i].property == "accZ")
							this._guiFingerSliders.__controllers[i].setValue(az);
					}

					for (var i = 0; i < this._GUI_gloveFolder.__controllers.length; i++) {
						 if (this._GUI_gloveFolder.__controllers[i].property == "Battery")
							this._GUI_gloveFolder.__controllers[i].setValue(this._battery);
					}
				}
			}
        }

        function GetBaseLog(x, y) {
          return Math.log(y) / Math.log(x);
        }

        class Finger {
            constructor() {
                this._fingerBones = [];
                this._normalizedRawValue = 0.0;
                this._multiplyValue = 1.0;
                this._multiplyKoef = 1.0;
            }

            InitBones(_hand, bonesNames) {
                for (var i = 0; i < bonesNames.length; i++) {
                    this._fingerBones[i] = _hand.getObjectByName(bonesNames[i]);
                }
            }


            Update(newValue) {

                let f_01 = map(newValue, 0, 255, 0.0, 1.0);
                this._normalizedRawValue = f_01;
                this._multiplyValue = Math.pow(this._normalizedRawValue, this._multiplyKoef);

                for (var i = 0; i < this._fingerBones.length; i++) {
                    this._fingerBones[i].rotation.z = map(this._multiplyValue, 0.0, 1.0, THREE.Math.degToRad(90), 0);
                }
            }
        }

        function CallibratePulsoFingers(isRightHand) {
            if (isRightHand) {
                PULSO_R.CallibrateFingers();
            }
            else {
                PULSO_L.CallibrateFingers();
            }
        }

        function SetGyroZero(isRightHand)
        {
            if (isRightHand) {
                //PULSO_R._offset.multiplyQuaternions(gyroPivotPoint[0].quaternion.clone(), PULSO_R._originRotationLocal.clone().invert());
                PULSO_R._offset.multiplyQuaternions(PULSO_R._lastGyro.clone(), PULSO_R._originRotationLocal.clone().invert());
            }
            else {
                PULSO_L._offset.multiplyQuaternions(PULSO_L._lastGyro.clone(), PULSO_L._originRotationLocal.clone().invert());
            }
            
        }

        function NormalizeAngle(angle)
        {
            var newAngle = angle;
            while (newAngle <= -180) newAngle += 360;
            while (newAngle > 180) newAngle -= 360;
            return newAngle;
        }

        //PULSO HID COMMANDS (Requests)

        function SwitchNormal(isRightHand) {
            const repData = [12];
            SendToHID(repData, isRightHand);
        }

        function SwitchGyro(isRightHand) {
            gyro = 1 - gyro;
            const repData = [3];
            SendToHID(repData, isRightHand);
        }
		
		function SwitchRaw(isRightHand) {
            raw = 1 - raw;
            const repData = [13];
            SendToHID(repData, isRightHand);
        }


        function Vibro(isRightHand) {
            const repData = [2];
            SendToHID(repData, isRightHand);
        }

        function CallibrateGyro(isRightHand) {
 		const repData = [14];
            SendToHID(repData, isRightHand);
        }

        function StartSend(isRightHand) {
            const repData = [1];
            SendToHID(repData, isRightHand);
        }

        function StopSend(isRightHand) {
            const repData = [5];
            SendToHID(repData, isRightHand);
        }

        function Callibrate(isRightHand) {
            const repData = [9];
            SendToHID(repData, isRightHand);
        }

        function Reset(isRightHand) {
            const repData = [6];
            SendToHID(repData, isRightHand);


            if (isRightHand) {
                PULSO_R.ResetCallibration();
            } else {PULSO_L.ResetCallibration();}

            }

        async function SendToHID(repData, isRightHand)
        {
            if (isRightHand)
            {
                await await HIDDevice_R.sendReport(0x02, new Uint8Array(repData));
            }
            else
            {
                await await HIDDevice_L.sendReport(0x02, new Uint8Array(repData));
            }
        }

       
        var container, stats;
        let controls;

 	var scene;
        let camera, renderer;
        var mesh, mesh2, mesh3;

        var hand, hand2;

        var gyro = 0;
		var raw = 0;


        var loadedModel = 0;

        var parseMinus = [1, 1, -1, 1];
        var gyroPivotPoint = [];

        var hidedMaterial = new THREE.MeshPhongMaterial();

        var PULSO_R;
        var HIDDevice_R;
        var PULSO_L;
        var HIDDevice_L;

        var SignRecognizer = new AIProcessor(20);

        var sphere;
        var sphereRotate = false;
        var sphereRotOffset = new THREE.Quaternion(0, 0, 0, 1);

        init();
        animate();


        function init() {

            container = document.createElement('div');
            document.body.appendChild(container);

            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 1000);
            camera.position.x = 0;
            camera.position.y = 5;
            camera.position.z = 0;

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x3e3e3e);//0xe0e0e0 );
            scene.fog = new THREE.Fog(0xe0e0e0, 20, 100);


            const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444);
            hemiLight.position.set(0, 200, 0);
            scene.add(hemiLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 3.0);
            dirLight.position.set(0, 200, 100);
            dirLight.castShadow = true;
            dirLight.shadow.camera.top = 180;
            dirLight.shadow.camera.bottom = - 100;
            dirLight.shadow.camera.left = - 120;
            dirLight.shadow.camera.right = 120;
            scene.add(dirLight);

            
            const texture = new THREE.TextureLoader().load('textures/360.jpg');

            const geometry = new THREE.SphereGeometry( 15, 32, 32 );
            const material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide});
            

            sphere = new THREE.Mesh(geometry, material);//THREE.Object3D();//
            sphere.position.x = 0;
            sphere.position.y = 0;
            sphere.position.z = 0;
            //mesh.visible = false;
            //scene.add(sphere);

            /*

            mesh = new THREE.Mesh(geometry, material);//THREE.Object3D();//
            mesh.position.x = -3;
            mesh.position.y = 0;
            mesh.position.z = 0;
            mesh.visible = false;
            scene.add(mesh);
            

            mesh2 = new THREE.Mesh(geometry, material);
            mesh2.position.x = -2;
            mesh2.position.y = 0;
            mesh2.position.z = 0;
            mesh2.visible = false;
            scene.add(mesh2);

            mesh3 = new THREE.Mesh(geometry, material);
            mesh3.position.x = 3;
            mesh3.position.y = 0;
            mesh3.position.z = 0;
            //mesh3.visible = false;
            scene.add(mesh3);
            //mesh3.rotation.z = degrees_to_radians(-90);
            */

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            //transformControl = new TransformControls( camera, renderer.domElement );
            controls = new OrbitControls(camera, renderer.domElement);
            //controls.listenToKeyEvents( window ); // optional



            window.addEventListener('resize', onWindowResize);

            //controls.autoRotate = true;
            //controls.addEventListener( 'change', render ); // call this only in static scenes (i.e., if there is no animation loop)

            //controls.enableDamping = true; // an animation loop is required when either damping or auto-rotation are enabled
            //controls.dampingFactor = 0.05;

            controls.screenSpacePanning = false;

            controls.minDistance = 0.01;
            controls.maxDistance = 100;


            //controls.maxPolarAngle = Math.PI / 2;

            gyroPivotPoint[0] = new THREE.Object3D();
            gyroPivotPoint[0].position.x = 2;
            gyroPivotPoint[0].position.y = 0;
            gyroPivotPoint[0].position.z = 0;

            scene.add(gyroPivotPoint[0]);

            gyroPivotPoint[1] = new THREE.Object3D();
            gyroPivotPoint[1].position.x = -2;
            gyroPivotPoint[1].position.y = 0;
            gyroPivotPoint[1].position.z = 0;

            scene.add(gyroPivotPoint[1]);

            gyroPivotPoint[0].name = 'GYRO_R';
            gyroPivotPoint[1].name = 'GYRO_L';


            //gyroPivotPoint.rotation.set ( 0.0, 0.0, 0.0, "XYZ" );




            // model
            const loader = new FBXLoader();
            loader.load('/vr_glove_right_model.fbx', function (object) {

                hand = object;

                hand.position.x = 0;
                hand.position.y = 0;
                hand.position.z = 0;

                hand.scale.set(10, 10, 10);
                // LEFT HAND
                //hand.scale.set(-10, 10, 10);


                //console.log(gyroPivotPoint);
                gyroPivotPoint[0].add(hand);
                //mesh3.add(hand);
                PostInit();

            });

            const loader2 = new FBXLoader();
            loader2.load('/vr_glove_right_model.fbx', function (object) {

                hand2 = object;

                hand2.position.x = 0;
                hand2.position.y = 0;
                hand2.position.z = 0;

                hand2.scale.set(-10, 10, 10);

                //scene.add(hand2);
                gyroPivotPoint[1].add(hand2);
                PostInit();
            });

            container.appendChild(renderer.domElement);
            //stats = new Stats();
            //container.appendChild( stats.dom );
        }


        function PostInit() {

            if (loadedModel == 0) {
                console.log("Wait second model...");
                loadedModel = 1;
                return;
            }

            console.log("...LOADED");



            PULSO_R = new PulsoHand(hand, true);
            PULSO_R.InitFingers();
            console.log(PULSO_R);


            PULSO_L = new PulsoHand(hand2, false);
            PULSO_L.InitFingers();
            console.log(PULSO_L);

            //hand.rotation.set ( 90.0, 0.0, 0.0, "XYZ" );
            //gyroPivotPoint.rotation.set ( 180.0, -90.0, 0.0, "XYZ" );
            /*
                gyroPivotPoint.rotation.x = degrees_to_radians(180.0);
                gyroPivotPoint.rotation.y = degrees_to_radians(180.0);
            gyroPivotPoint.rotation.z = degrees_to_radians(180.0);
            */

            
            gyroPivotPoint[0].rotation.set
                (
                    degrees_to_radians(180),
                    degrees_to_radians(180),
                    degrees_to_radians(0),
                    "XYZ"
            );

            gyroPivotPoint[1].rotation.set
                (
                    degrees_to_radians(180),
                    degrees_to_radians(180),
                    degrees_to_radians(0),
                    "XYZ"
                );
                
            //console.log(originRotationLocal);
            PULSO_R._originRotationLocal.copy(gyroPivotPoint[0].quaternion.clone());
            PULSO_L._originRotationLocal.copy(gyroPivotPoint[1].quaternion.clone());

                        gyroPivotPoint[0].rotation.set
                (
                    degrees_to_radians(0),
                    degrees_to_radians(180),
                    degrees_to_radians(0),
                    "XYZ"
                        );

            PULSO_R._lastGyro.set(gyroPivotPoint[0].quaternion.x, gyroPivotPoint[0].quaternion.y, gyroPivotPoint[0].quaternion.z, gyroPivotPoint[0].quaternion.w);
            PULSO_L._lastGyro.set(gyroPivotPoint[1].quaternion.x, gyroPivotPoint[1].quaternion.y, gyroPivotPoint[1].quaternion.z, gyroPivotPoint[1].quaternion.w);

            //originRotationLocal = ConvertQuaternion(originRotationLocal.clone(), axisType);

            console.log(">>>>>>");
            // console.log(gyroPivotPoint.getWorldQuaternion( originRotationLocal ));
            //	console.log(originRotationLocal);

            //console.log(originRotationLocal);
            /*
                hand.rotation.x = degrees_to_radians(-90.0); //degrees_to_radians(90.0);
                hand.rotation.y = degrees_to_radians(1800.0);
            hand.rotation.z = degrees_to_radians(90.0);
            */


            hand.rotation.set
                (
                    degrees_to_radians(-90.0),
                    degrees_to_radians(180.0),
                    degrees_to_radians(90.0),
                    "XYZ"
            );

            hand2.rotation.set
                (
                    degrees_to_radians(-90.0),
                    degrees_to_radians(180.0),
                    degrees_to_radians(270.0),
                    "XYZ"
            );


            PULSO_R._inited = true;
            PULSO_L._inited = true;

            CreateGUI(PULSO_R);
            CreateGUI(PULSO_L);

            //PULSO_R._gui.close();
            //PULSO_L._gui.close();

            //ShowHideBoxes(false);
        }

        function onWindowResize() {

            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize(window.innerWidth, window.innerHeight);

        }


        ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


        function animate() {

            

            if (PULSO_R && PULSO_R._inited) {

                let newQuaternion = PULSO_R._lastGyro.clone();
                newQuaternion = ConvertQuaternion(newQuaternion, PULSO_R._axisType);
                let axisConvertedQuat = newQuaternion.multiplyQuaternions(PULSO_R._offset, newQuaternion).normalize();
                gyroPivotPoint[0].quaternion.copy(axisConvertedQuat);

                /*
                gyroPivotPoint[0].quaternion.copy(PULSO_R._lastGyro);
                let newQuaternion = PULSO_R._lastGyro.clone();
                mesh.quaternion.copy(newQuaternion);

                //==================


                newQuaternion = ConvertQuaternion(gyroPivotPoint[0].quaternion, PULSO_R._axisType);
                mesh2.quaternion.copy(newQuaternion);

                //========================================

                let axisConvertedQuat = newQuaternion.multiplyQuaternions(PULSO_R._offset, newQuaternion).normalize();
                mesh3.quaternion.copy(axisConvertedQuat);

                SignRecognizer.UpdateBuffer(PULSO_R._fingersArray_0_to_255[1]);
                //console.log(SignRecognizer._buffer);
                */

                /*
                let peaks = SignRecognizer.DetectPeaks(SignRecognizer._buffer, 4, 3);
                //document.querySelector("#debug").innerHTML = SignRecognizer._buffer;
                if (peaks > 0)
                    console.log(peaks);
                */


                data.push(PULSO_R._fingersArray_0_to_255[0]);
                data2.push(PULSO_R._fingersArray_0_to_255[1]);
                data3.push(PULSO_R._fingersArray_0_to_255[2]);
                data4.push(PULSO_R._fingersArray_0_to_255[3]);
                data5.push(PULSO_R._fingersArray_0_to_255[4]);

                animateGraph();
                let peaks = SignRecognizer.DetectPeaks(data, 50, 5);
                if (peaks > 0)
                    console.log(peaks);

                if (sphereRotate === false)
                {
                    //if (PULSO_R._fingers[0]._multiplyValue < 0.6 && PULSO_R._fingers[1]._multiplyValue < 0.6) {
                    if (PULSO_R._fingers[1]._multiplyValue < 0.70) {
                        StartRotate();
                        console.log("START");
                    }
                }
                else
                {
                    //if (PULSO_R._fingers[0]._multiplyValue > 0.7 && PULSO_R._fingers[1]._multiplyValue > 0.7) {
                    if (PULSO_R._fingers[1]._multiplyValue > 0.75) {
                        sphereRotate = false;
                        console.log("STOP");
                    }
                }
            }

            if (PULSO_L && PULSO_L._inited)
            {
                let newQuaternion = PULSO_L._lastGyro.clone();
                newQuaternion = ConvertQuaternion(newQuaternion, PULSO_L._axisType);
                let axisConvertedQuat = newQuaternion.multiplyQuaternions(PULSO_L._offset, newQuaternion).normalize();
                gyroPivotPoint[1].quaternion.copy(axisConvertedQuat);
            }

            if (sphereRotate) {
                RotateSphere();
            }

            requestAnimationFrame(animate);
            render();
        }

        function render() {
            //stats.update();

            //controls.update(); // only required if controls.enableDamping = true, or if controls.autoRotate = true
            renderer.render(scene, camera);

        }


        console.log("START...");


        function map(x, in_min, in_max, out_min, out_max) {
            return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
        }


        function CreateGUI(pulsoHand) {

            let gui = new GUI({ autoPlace: false });

            pulsoHand._gui = gui;

            console.log("GUI>>>");
            console.log(pulsoHand);

            gui.add(pulsoHand._params, 'HID_Data');
            var f1 = gui.addFolder('Connection');
            f1.add(pulsoHand._params, 'Connect');
            f1.add(pulsoHand._params, 'StartSend');
            f1.add(pulsoHand._params, 'StopSend');
            f1.add(pulsoHand._params, 'SwitchNormal');
            f1.add(pulsoHand._params, 'SwitchGyro');
			f1.add(pulsoHand._params, 'SwitchRaw');
            f1.open();

            var f2 = gui.addFolder('Glove');
            f2.add(pulsoHand._params, 'Battery', 0, 100);
            f2.add(pulsoHand._params, 'handZPos', -3, 4).step(0.01).onChange(function (value) { pulsoHand._hand.position.y = value; });

            let id = 0;
            if (pulsoHand._rightHand === false) {
                id = 1;
            }
            f2.add(pulsoHand._params, 'handXPos', -4, 4).step(0.01).onChange(function (value) { gyroPivotPoint[id].position.x = value; });

            f2.add(pulsoHand._params, 'CallibrateFingersPose');
            f2.add(pulsoHand._params, 'SetGyroZero');
            f2.add(pulsoHand._params, 'Vibro');
            f2.add(pulsoHand._params, 'Callibrate');
            f2.add(pulsoHand._params, 'Reset');
		 f2.add(pulsoHand._params, 'CallibrateGyro');

            pulsoHand._GUI_gloveFolder = f2;

            var f3 = gui.addFolder('Debug hand');

            f3.add(pulsoHand._params, 'SetMinuses');
            f3.add(pulsoHand._params, 'SetHandRot');

            //gui.add(pulsoHand._params, 'DrawBoxes').onChange(function (value) {ShowHideBoxes(value); });

            gui.addColor(pulsoHand._params, 'SceneColor').onChange(function (value) {
               scene.background = new THREE.Color(value);
            });

            pulsoHand._guiFingerSliders = gui.addFolder('Fingers');
            pulsoHand._guiFingerSliders.add(pulsoHand._params, 'finger0', 0.0, 1.0).step(0.01).onChange(function (value) { });
            pulsoHand._guiFingerSliders.add(pulsoHand._params, 'finger1', 0.0, 1.0).step(0.01).onChange(function (value) { });
            pulsoHand._guiFingerSliders.add(pulsoHand._params, 'finger2', 0.0, 1.0).step(0.01).onChange(function (value) { });
            pulsoHand._guiFingerSliders.add(pulsoHand._params, 'finger3', 0.0, 1.0).step(0.01).onChange(function (value) { });
            pulsoHand._guiFingerSliders.add(pulsoHand._params, 'finger4', 0.0, 1.0).step(0.01).onChange(function (value) { });

            
            pulsoHand._guiFingerSliders.add(pulsoHand._params, 'rotX', -180, 180);
            pulsoHand._guiFingerSliders.add(pulsoHand._params, 'rotY', -180, 180);
            pulsoHand._guiFingerSliders.add(pulsoHand._params, 'rotZ', -180, 180);


            pulsoHand._guiFingerSliders.add(pulsoHand._params, 'accX', 0, 255);
            pulsoHand._guiFingerSliders.add(pulsoHand._params, 'accY', 0, 255);
            pulsoHand._guiFingerSliders.add(pulsoHand._params, 'accZ', 0, 255);

            if (pulsoHand._rightHand) {
                gui.domElement.id = 'guiR';
                gui_containerR.appendChild(gui.domElement);
            }
            else {
                gui.domElement.id = 'guiL';
                gui_containerL.appendChild(gui.domElement);
            }
            
        }

        /*
        function ShowHideBoxes(value) {

            if (value) {
                mesh.visible = true;
                mesh2.visible = true;
                //mesh3.visible = true;
                mesh3.material = mesh.material;
            }
            else {
                mesh.visible = false;
                mesh2.visible = false;
                //mesh3.visible = false;

                mesh3.material = hidedMaterial;
                mesh3.material.visible = false;
            }
        }
        */

        function lerp (start, end, amt){
              return (1-amt)*start+amt*end
            }

        function radians_to_degrees(radians)
        {
          var pi = Math.PI;
          return radians * (180/pi);
        }


        function degrees_to_radians(degrees) {
            var pi = Math.PI;
            return degrees * (pi / 180);
        }



        //////////////////////////////////////////////////////////////////////////////////////////////////////

        function SetMinuses() {


            axisType = parseInt(document.querySelector('#axisType').value);

            parseMinus[0] = parseInt(document.querySelector('#mX').value);
            parseMinus[1] = parseInt(document.querySelector('#mY').value);
            parseMinus[2] = parseInt(document.querySelector('#mZ').value);
            parseMinus[3] = parseInt(document.querySelector('#mW').value);

            console.log(axisType);
            console.log(parseMinus);
        }


        function SetHandRot() {
            hand.rotation.set
                (
                    degrees_to_radians(parseInt(document.querySelector('#rX').value)),
                    degrees_to_radians(parseInt(document.querySelector('#rY').value)),
                    degrees_to_radians(parseInt(document.querySelector('#rZ').value)),
                    "XYZ"
                );

            console.log(hand.rotation);
        }


        async function ConnectPulsoBluetooth(isRightHand)
        {
const filtersR = [{
                    vendorId: 58626, //0xe502 //vendorId: 741, //0x02e5
                    productId: 10 // PULSO Right
                }];

const filtersL = [{
		    vendorId:58626, //0xe502//vendorId: 741, //0x02e5
                    productId: 11 // PULSO Left
                }];

const waitFor = duration => new Promise(r => setTimeout(r, duration));

console.log(isRightHand);
let devices;
	if (isRightHand === true)
	{
		console.log(navigator.hid);
             devices = await navigator.hid.requestDevice({ filters: filtersR });
	}
	else
	{
		devices = await navigator.hid.requestDevice({ filters: filtersL });
	}

            console.log(isRightHand);

            if (isRightHand) {
                console.log("Connect R");
                HIDDevice_R = devices[0];
                await HIDDevice_R.open();

                if (HIDDevice_R === undefined) {
                    console.log("Pulso device NOT selected.");
                }
		
			console.log(HIDDevice_R.vendorId);
			console.log(HIDDevice_R.productId);
			console.log(HIDDevice_R.productName);

                //HIDDevice_R.oninputreport = (event) => { let gloveData = new Uint8Array(event.data.buffer); PULSO_R.ParseData(gloveData); };
				HIDDevice_R.addEventListener("inputreport", event => {
					const { data, device, reportId } = event;
					//console.log(data, reportId)
					// Handle only the Joy−Con Right device and a speci!c report ID.
					if (reportId == 0x01){
						const value = data.getUint8(0);
						if (value === 0) return;
						PULSO_R.ParseData(1, data);
					}
					if (reportId == 0x03){
						const value = data.getUint8(0);
						if (value === 0) return;
						PULSO_R.ParseData(3, data);
					}
					});
            }
            else
            {
                console.log("Connect L");
                HIDDevice_L = devices[0];
                await HIDDevice_L.open();

                if (HIDDevice_L === undefined) {
                    console.log("Pulso L device NOT selected.");
                }
		
			console.log(HIDDevice_L.vendorId);
			console.log(HIDDevice_L.productId);
			console.log(HIDDevice_L.productName);

                //HIDDevice_R.oninputreport = (event) => { let gloveData = new Uint8Array(event.data.buffer); PULSO_R.ParseData(gloveData); };
				HIDDevice_L.addEventListener("inputreport", event => {
					const { data, device, reportId } = event;
					//console.log(data, reportId)
					// Handle only the Joy−Con Right device and a speci!c report ID.
					if (reportId == 0x01){
						const value = data.getUint8(0);
						if (value === 0) return;
						PULSO_L.ParseData(1, data);
					}
					if (reportId == 0x03){
						const value = data.getUint8(0);
						if (value === 0) return;
						PULSO_L.ParseData(3, data);
					}
					});
            }
        }

        function ConvertQuaternion(rightHandedQuaternion, type) {
            switch (type) {
                case 0: return new THREE.Quaternion().set(-rightHandedQuaternion.x, -rightHandedQuaternion.z, -rightHandedQuaternion.y, rightHandedQuaternion.w); break;
                case 1: return new THREE.Quaternion().set(-rightHandedQuaternion.y, -rightHandedQuaternion.z, -rightHandedQuaternion.x, rightHandedQuaternion.w); break;
                case 2: return new THREE.Quaternion().set(-rightHandedQuaternion.y, -rightHandedQuaternion.x, -rightHandedQuaternion.z, rightHandedQuaternion.w); break;
                case 3: return new THREE.Quaternion().set(-rightHandedQuaternion.z, -rightHandedQuaternion.x, -rightHandedQuaternion.y, rightHandedQuaternion.w); break;
                //case 4: return new new THREE.Quaternion().set(-rightHandedQuaternion.z, -rightHandedQuaternion.y, -rightHandedQuaternion.x, rightHandedQuaternion.w); break;

                case 4: return new THREE.Quaternion().set(
                    rightHandedQuaternion.x * parseMinus[0],
                    rightHandedQuaternion.y * parseMinus[1],
                    rightHandedQuaternion.z * parseMinus[2],
                    rightHandedQuaternion.w * parseMinus[3]);
                    break;


                case 5: return new THREE.Quaternion().set(
                    rightHandedQuaternion.x * parseMinus[0],
                    rightHandedQuaternion.z * parseMinus[1],
                    rightHandedQuaternion.y * parseMinus[2],
                    rightHandedQuaternion.w * parseMinus[3]);
                    break;

                case 6: return new THREE.Quaternion().set(
                    rightHandedQuaternion.y * parseMinus[0],
                    rightHandedQuaternion.z * parseMinus[1],
                    rightHandedQuaternion.x * parseMinus[2],
                    rightHandedQuaternion.w * parseMinus[3]);
                    break;
                case 7: return new THREE.Quaternion().set(
                    rightHandedQuaternion.y * parseMinus[0],
                    rightHandedQuaternion.x * parseMinus[1],
                    rightHandedQuaternion.z * parseMinus[2],
                    rightHandedQuaternion.w * parseMinus[3]);
                    break;
                case 8: return new THREE.Quaternion().set(
                    rightHandedQuaternion.z * parseMinus[0],
                    rightHandedQuaternion.x * parseMinus[1],
                    rightHandedQuaternion.y * parseMinus[2],
                    rightHandedQuaternion.w * parseMinus[3]);
                    break;
                case 9: return new THREE.Quaternion().set(
                    rightHandedQuaternion.z * parseMinus[0],
                    rightHandedQuaternion.y * parseMinus[1],
                    rightHandedQuaternion.x * parseMinus[2],
                    rightHandedQuaternion.w * parseMinus[3]);
                    break;
            }

            return rightHandedQuaternion;
        }


       function StartRotate() {

           sphereRotOffset.multiplyQuaternions(gyroPivotPoint[0].quaternion.clone().invert(), sphere.quaternion.clone());
            sphereRotate = true;
        }

        function RotateSphere() {
            sphere.quaternion.multiplyQuaternions(gyroPivotPoint[0].quaternion, sphereRotOffset).normalize();
        }

</script>

    <div id="graphContainer">
     <canvas id="myCanvas" width="150" height="255"></canvas>
        </div>

</body>

</html>